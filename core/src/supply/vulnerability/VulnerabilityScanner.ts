import { ccmHash } from "../../crypto/ccm/CCMHash";
import { SBOM } from "../sbom/SBOM";
import { ReproManifest } from "../repro/Repro";
import { Provenance } from "../provenance/Provenance";
import { SignedRelease } from "../release/Sign";

/**
 * Vulnerability scanning for supply chain validation
 * Implements comprehensive security analysis with holographic correspondence
 */

export interface Vulnerability {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  title: string;
  description: string;
  component: string;
  version: string;
  cve?: string;
  cvss?: number;
  remediation: string;
  holographic_correspondence: string;
}

export interface VulnerabilityScanResult {
  scanId: string;
  timestamp: number;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  riskScore: number; // 0-10
  recommendations: string[];
  holographic_correspondence: string;
}

export interface VulnerabilityScanConfig {
  enableCVE: boolean;
  enableCVSS: boolean;
  enableDependencyScan: boolean;
  enableCodeScan: boolean;
  enableLicenseScan: boolean;
  severityThreshold: 'critical' | 'high' | 'medium' | 'low' | 'info';
  maxScanTime: number; // milliseconds
  cacheResults: boolean;
  cacheExpiry: number; // milliseconds
}

export interface ScanContext {
  sbom: SBOM;
  repro: ReproManifest;
  provenance: Provenance;
  signedRelease: SignedRelease;
  scanConfig: VulnerabilityScanConfig;
}

/**
 * Vulnerability scanner with comprehensive security analysis
 */
export class VulnerabilityScanner {
  private config: VulnerabilityScanConfig;
  private vulnerabilityDatabase: Map<string, Vulnerability> = new Map();
  private scanCache: Map<string, VulnerabilityScanResult> = new Map();
  private knownVulnerabilities: Map<string, Vulnerability[]> = new Map();

  constructor(config: Partial<VulnerabilityScanConfig> = {}) {
    this.config = {
      enableCVE: config.enableCVE !== false,
      enableCVSS: config.enableCVSS !== false,
      enableDependencyScan: config.enableDependencyScan !== false,
      enableCodeScan: config.enableCodeScan !== false,
      enableLicenseScan: config.enableLicenseScan !== false,
      severityThreshold: config.severityThreshold || 'medium',
      maxScanTime: config.maxScanTime || 30000, // 30 seconds
      cacheResults: config.cacheResults !== false,
      cacheExpiry: config.cacheExpiry || 3600000 // 1 hour
    };
    
    this.initializeVulnerabilityDatabase();
  }

  /**
   * Scans supply chain components for vulnerabilities
   */
  async scanSupplyChain(context: ScanContext): Promise<VulnerabilityScanResult> {
    const scanId = this.generateScanId(context);
    
    // Check cache first
    if (this.config.cacheResults) {
      const cached = this.getCachedResult(scanId);
      if (cached) {
        return cached;
      }
    }
    
    const startTime = Date.now();
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      // 1. Scan SBOM dependencies
      if (this.config.enableDependencyScan) {
        const sbomVulns = await this.scanSBOM(context.sbom);
        vulnerabilities.push(...sbomVulns);
      }
      
      // 2. Scan reproducible build artifacts
      if (this.config.enableCodeScan) {
        const reproVulns = await this.scanReproManifest(context.repro);
        vulnerabilities.push(...reproVulns);
      }
      
      // 3. Scan provenance chain
      const provenanceVulns = await this.scanProvenance(context.provenance);
      vulnerabilities.push(...provenanceVulns);
      
      // 4. Scan release signatures
      const releaseVulns = await this.scanSignedRelease(context.signedRelease);
      vulnerabilities.push(...releaseVulns);
      
      // 5. Cross-component analysis
      const crossVulns = await this.scanCrossComponents(context);
      vulnerabilities.push(...crossVulns);
      
      // Filter by severity threshold
      const filteredVulns = this.filterBySeverity(vulnerabilities);
      
      // Generate scan result
      const result = this.generateScanResult(scanId, filteredVulns, startTime);
      
      // Cache result
      if (this.config.cacheResults) {
        this.cacheResult(scanId, result);
      }
      
      return result;
      
    } catch (error) {
      // Return error result
      return this.generateErrorResult(scanId, error, startTime);
    }
  }

  /**
   * Scans SBOM for dependency vulnerabilities
   */
  private async scanSBOM(sbom: SBOM): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Analyze components
    if (sbom.components) {
      for (const component of sbom.components) {
        const depVulns = await this.scanDependency(component.name, component);
        vulnerabilities.push(...depVulns);
      }
    }
    
    // Check for known vulnerable packages
    const knownVulns = this.checkKnownVulnerabilities(sbom);
    vulnerabilities.push(...knownVulns);
    
    return vulnerabilities;
  }

  /**
   * Scans reproducible build manifest
   */
  private async scanReproManifest(repro: ReproManifest): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for suspicious file patterns
    for (const entry of repro.entries) {
      const fileVulns = this.scanFileEntry(entry);
      vulnerabilities.push(...fileVulns);
    }
    
    // Check for integrity issues
    const integrityVulns = this.checkIntegrityIssues(repro);
    vulnerabilities.push(...integrityVulns);
    
    return vulnerabilities;
  }

  /**
   * Scans provenance chain
   */
  private async scanProvenance(provenance: Provenance): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check commit integrity
    if (!this.isValidCommit(provenance.commit)) {
      vulnerabilities.push(this.createVulnerability({
        id: 'prov-commit-invalid',
        severity: 'high',
        title: 'Invalid commit hash in provenance',
        description: 'The commit hash in provenance does not match expected format',
        component: 'provenance',
        version: provenance.v.toString(),
        remediation: 'Verify commit hash format and integrity'
      }));
    }
    
    // Check blueprint digest
    if (!this.isValidDigest(provenance.blueprintDigest)) {
      vulnerabilities.push(this.createVulnerability({
        id: 'prov-blueprint-invalid',
        severity: 'high',
        title: 'Invalid blueprint digest in provenance',
        description: 'The blueprint digest in provenance is invalid',
        component: 'provenance',
        version: provenance.v.toString(),
        remediation: 'Verify blueprint digest integrity'
      }));
    }
    
    return vulnerabilities;
  }

  /**
   * Scans signed release
   */
  private async scanSignedRelease(signedRelease: SignedRelease): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check signature integrity
    if (!this.isValidSignature(signedRelease.signature)) {
      vulnerabilities.push(this.createVulnerability({
        id: 'release-sig-invalid',
        severity: 'critical',
        title: 'Invalid release signature',
        description: 'The release signature is invalid or corrupted',
        component: 'signed-release',
        version: '1.0',
        remediation: 'Verify release signature and signing key'
      }));
    }
    
    // Check bundle integrity
    if (!this.isValidBundle(signedRelease.bundle)) {
      vulnerabilities.push(this.createVulnerability({
        id: 'release-bundle-invalid',
        severity: 'high',
        title: 'Invalid release bundle',
        description: 'The release bundle structure is invalid',
        component: 'signed-release',
        version: '1.0',
        remediation: 'Verify bundle structure and contents'
      }));
    }
    
    return vulnerabilities;
  }

  /**
   * Scans cross-component interactions
   */
  private async scanCrossComponents(context: ScanContext): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check digest consistency across components
    const digestVulns = this.checkDigestConsistency(context);
    vulnerabilities.push(...digestVulns);
    
    // Check version consistency
    const versionVulns = this.checkVersionConsistency(context);
    vulnerabilities.push(...versionVulns);
    
    // Check temporal consistency
    const temporalVulns = this.checkTemporalConsistency(context);
    vulnerabilities.push(...temporalVulns);
    
    return vulnerabilities;
  }

  /**
   * Scans individual dependency
   */
  private async scanDependency(name: string, dep: any): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for known vulnerable versions
    const knownVulns = this.checkDependencyVulnerabilities(name, dep.version);
    vulnerabilities.push(...knownVulns);
    
    // Check for license issues
    if (this.config.enableLicenseScan) {
      const licenseVulns = this.checkLicenseCompliance(name, dep.license);
      vulnerabilities.push(...licenseVulns);
    }
    
    // Check for suspicious metadata
    const metadataVulns = this.checkDependencyMetadata(name, dep);
    vulnerabilities.push(...metadataVulns);
    
    return vulnerabilities;
  }

  /**
   * Scans file entry for vulnerabilities
   */
  private scanFileEntry(entry: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for suspicious file extensions
    if (this.isSuspiciousFile(entry.path)) {
      vulnerabilities.push(this.createVulnerability({
        id: 'file-suspicious-extension',
        severity: 'medium',
        title: 'Suspicious file extension detected',
        description: `File ${entry.path} has a suspicious extension`,
        component: 'repro-manifest',
        version: '1.0',
        remediation: 'Review file contents and verify legitimacy'
      }));
    }
    
    // Check for executable files in unexpected locations
    if (this.isExecutableInUnexpectedLocation(entry)) {
      vulnerabilities.push(this.createVulnerability({
        id: 'file-executable-unexpected',
        severity: 'high',
        title: 'Executable file in unexpected location',
        description: `Executable file ${entry.path} found in unexpected location`,
        component: 'repro-manifest',
        version: '1.0',
        remediation: 'Verify file placement and review contents'
      }));
    }
    
    return vulnerabilities;
  }

  /**
   * Checks for integrity issues in repro manifest
   */
  private checkIntegrityIssues(repro: ReproManifest): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for missing or corrupted entries
    for (const entry of repro.entries) {
      if (!entry.digest || entry.digest.length !== 64) {
        vulnerabilities.push(this.createVulnerability({
          id: 'repro-entry-invalid-digest',
          severity: 'high',
          title: 'Invalid entry digest in repro manifest',
          description: `Entry ${entry.path} has invalid digest`,
          component: 'repro-manifest',
          version: '1.0',
          remediation: 'Verify file integrity and regenerate manifest'
        }));
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Checks digest consistency across components
   */
  private checkDigestConsistency(context: ScanContext): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Verify SBOM digest matches
    if (context.signedRelease.bundle.sbomDigest !== context.sbom.digest) {
      vulnerabilities.push(this.createVulnerability({
        id: 'digest-sbom-mismatch',
        severity: 'critical',
        title: 'SBOM digest mismatch',
        description: 'SBOM digest in release bundle does not match actual SBOM',
        component: 'cross-component',
        version: '1.0',
        remediation: 'Verify SBOM integrity and regenerate release'
      }));
    }
    
    // Verify repro digest matches
    if (context.signedRelease.bundle.reproDigest !== context.repro.digest) {
      vulnerabilities.push(this.createVulnerability({
        id: 'digest-repro-mismatch',
        severity: 'critical',
        title: 'Repro digest mismatch',
        description: 'Repro digest in release bundle does not match actual repro',
        component: 'cross-component',
        version: '1.0',
        remediation: 'Verify repro integrity and regenerate release'
      }));
    }
    
    return vulnerabilities;
  }

  /**
   * Checks version consistency across components
   */
  private checkVersionConsistency(context: ScanContext): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for version mismatches
    const versions = new Set([
      context.sbom.v?.toString() || 'unknown',
      context.repro.v?.toString() || 'unknown',
      context.provenance.v?.toString() || 'unknown'
    ]);
    
    if (versions.size > 1) {
      vulnerabilities.push(this.createVulnerability({
        id: 'version-inconsistency',
        severity: 'medium',
        title: 'Version inconsistency across components',
        description: 'Different version numbers found across supply chain components',
        component: 'cross-component',
        version: '1.0',
        remediation: 'Ensure consistent versioning across all components'
      }));
    }
    
    return vulnerabilities;
  }

  /**
   * Checks temporal consistency
   */
  private checkTemporalConsistency(context: ScanContext): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for temporal anomalies (future timestamps, etc.)
    const now = Date.now();
    const futureThreshold = now + (24 * 60 * 60 * 1000); // 24 hours in future
    
    // This would check timestamps in provenance, repro, etc.
    // For now, we'll do a basic check
    
    return vulnerabilities;
  }

  /**
   * Checks for known vulnerabilities in dependency
   */
  private checkDependencyVulnerabilities(name: string, version: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check against known vulnerability database
    const knownVulns = this.knownVulnerabilities.get(name) || [];
    for (const vuln of knownVulns) {
      if (this.isVersionAffected(version, vuln)) {
        vulnerabilities.push(vuln);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Checks license compliance
   */
  private checkLicenseCompliance(name: string, license: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for problematic licenses
    const problematicLicenses = ['GPL-3.0', 'AGPL-3.0', 'SSPL-1.0'];
    if (problematicLicenses.includes(license)) {
      vulnerabilities.push(this.createVulnerability({
        id: `license-${license.toLowerCase()}`,
        severity: 'medium',
        title: `Problematic license detected: ${license}`,
        description: `Dependency ${name} uses ${license} license which may have compliance issues`,
        component: name,
        version: 'unknown',
        remediation: 'Review license terms and consider alternatives'
      }));
    }
    
    return vulnerabilities;
  }

  /**
   * Checks dependency metadata for suspicious patterns
   */
  private checkDependencyMetadata(name: string, dep: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for suspicious package names
    if (this.isSuspiciousPackageName(name)) {
      vulnerabilities.push(this.createVulnerability({
        id: 'dep-suspicious-name',
        severity: 'medium',
        title: 'Suspicious package name detected',
        description: `Package name "${name}" appears suspicious`,
        component: name,
        version: dep.version || 'unknown',
        remediation: 'Verify package authenticity and source'
      }));
    }
    
    return vulnerabilities;
  }

  /**
   * Helper methods
   */
  private generateScanId(context: ScanContext): string {
    return ccmHash({
      sbom: context.sbom.digest,
      repro: context.repro.digest,
      provenance: context.provenance.digest
    }, 'vulnerability_scan');
  }

  private createVulnerability(data: Omit<Vulnerability, 'holographic_correspondence'>): Vulnerability {
    return {
      ...data,
      holographic_correspondence: ccmHash(data, 'vulnerability')
    };
  }

  private filterBySeverity(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1, info: 0 };
    const threshold = severityOrder[this.config.severityThreshold];
    
    return vulnerabilities.filter(v => severityOrder[v.severity] >= threshold);
  }

  private generateScanResult(scanId: string, vulnerabilities: Vulnerability[], startTime: number): VulnerabilityScanResult {
    const summary = this.calculateSummary(vulnerabilities);
    const riskScore = this.calculateRiskScore(vulnerabilities);
    const recommendations = this.generateRecommendations(vulnerabilities);
    
    return {
      scanId,
      timestamp: startTime,
      vulnerabilities,
      summary,
      riskScore,
      recommendations,
      holographic_correspondence: ccmHash({
        scanId,
        vulnerabilities: vulnerabilities.length,
        summary,
        riskScore
      }, 'vulnerability_scan_result')
    };
  }

  private generateErrorResult(scanId: string, error: any, startTime: number): VulnerabilityScanResult {
    return {
      scanId,
      timestamp: startTime,
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      riskScore: 10, // Maximum risk on error
      recommendations: ['Scan failed - manual review required'],
      holographic_correspondence: ccmHash({
        scanId,
        error: error instanceof Error ? error.message : String(error)
      }, 'vulnerability_scan_error')
    };
  }

  private calculateSummary(vulnerabilities: Vulnerability[]): VulnerabilityScanResult['summary'] {
    const summary = { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 };
    
    for (const vuln of vulnerabilities) {
      summary.total++;
      summary[vuln.severity]++;
    }
    
    return summary;
  }

  private calculateRiskScore(vulnerabilities: Vulnerability[]): number {
    let score = 0;
    
    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
        case 'critical': score += 4; break;
        case 'high': score += 3; break;
        case 'medium': score += 2; break;
        case 'low': score += 1; break;
        case 'info': score += 0.5; break;
      }
    }
    
    return Math.min(10, score);
  }

  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];
    
    if (vulnerabilities.some(v => v.severity === 'critical')) {
      recommendations.push('Address critical vulnerabilities immediately');
    }
    
    if (vulnerabilities.some(v => v.severity === 'high')) {
      recommendations.push('Address high-severity vulnerabilities within 24 hours');
    }
    
    if (vulnerabilities.some(v => v.severity === 'medium')) {
      recommendations.push('Address medium-severity vulnerabilities within 1 week');
    }
    
    if (vulnerabilities.length === 0) {
      recommendations.push('No vulnerabilities detected - maintain current security practices');
    }
    
    return recommendations;
  }

  private getCachedResult(scanId: string): VulnerabilityScanResult | null {
    const cached = this.scanCache.get(scanId);
    if (cached && (Date.now() - cached.timestamp) < this.config.cacheExpiry) {
      return cached;
    }
    return null;
  }

  private cacheResult(scanId: string, result: VulnerabilityScanResult): void {
    this.scanCache.set(scanId, result);
  }

  private initializeVulnerabilityDatabase(): void {
    // Initialize with some known vulnerabilities for testing
    // In a real implementation, this would load from external databases
  }

  private checkKnownVulnerabilities(sbom: SBOM): Vulnerability[] {
    // Check against known vulnerability patterns
    return [];
  }

  private isValidCommit(commit: string): boolean {
    return /^[a-f0-9]{40}$/.test(commit);
  }

  private isValidDigest(digest: string): boolean {
    return /^[a-f0-9]{64}$/.test(digest);
  }

  private isValidSignature(signature: string | boolean): boolean {
    return typeof signature === 'string' && signature.length > 0;
  }

  private isValidBundle(bundle: any): boolean {
    return bundle && bundle.reproDigest && bundle.sbomDigest && bundle.provenanceDigest;
  }

  private isSuspiciousFile(path: string): boolean {
    const suspiciousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.pif'];
    return suspiciousExtensions.some(ext => path.toLowerCase().endsWith(ext));
  }

  private isExecutableInUnexpectedLocation(entry: any): boolean {
    // Check for executables in unexpected locations
    const unexpectedPaths = ['/tmp/', '/var/tmp/', '/dev/'];
    return unexpectedPaths.some(path => entry.path.startsWith(path));
  }

  private isVersionAffected(version: string, vulnerability: Vulnerability): boolean {
    // Simple version comparison - in real implementation, use proper semver
    return true; // Simplified for demo
  }

  private isSuspiciousPackageName(name: string): boolean {
    // Check for typosquatting patterns
    const suspiciousPatterns = [
      /^[a-z]+-[a-z]+-[a-z]+$/, // kebab-case with many parts
      /^[a-z]{1,2}$/, // very short names
      /[0-9]{4,}/, // many numbers
    ];
    
    // Also check for specific suspicious names
    const suspiciousNames = ['suspicious-pkg', 'test-package'];
    
    return suspiciousPatterns.some(pattern => pattern.test(name)) || 
           suspiciousNames.includes(name);
  }
}

/**
 * Global vulnerability scanner instance
 */
let globalScanner: VulnerabilityScanner | null = null;

/**
 * Get or create global vulnerability scanner
 */
export function getVulnerabilityScanner(config?: Partial<VulnerabilityScanConfig>): VulnerabilityScanner {
  if (!globalScanner) {
    globalScanner = new VulnerabilityScanner(config);
  }
  return globalScanner;
}
