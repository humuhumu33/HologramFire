import { describe, it, expect, beforeEach } from "vitest";
import { 
  VulnerabilityScanner, 
  getVulnerabilityScanner,
  VulnerabilityScanConfig,
  ScanContext
} from "../src/supply/vulnerability/VulnerabilityScanner";
import { SBOM } from "../src/supply/sbom/SBOM";
import { ReproManifest } from "../src/supply/repro/Repro";
import { Provenance } from "../src/supply/provenance/Provenance";
import { SignedRelease } from "../src/supply/release/Sign";

describe("Vulnerability Scanner for Supply Chain Validation", () => {
  let scanner: VulnerabilityScanner;
  let config: VulnerabilityScanConfig;
  let mockContext: ScanContext;

  beforeEach(() => {
    config = {
      enableCVE: true,
      enableCVSS: true,
      enableDependencyScan: true,
      enableCodeScan: true,
      enableLicenseScan: true,
      severityThreshold: 'medium',
      maxScanTime: 5000,
      cacheResults: true,
      cacheExpiry: 60000
    };
    scanner = new VulnerabilityScanner(config);
    
    // Create mock supply chain components
    const mockSBOM: SBOM = {
      v: 1,
      spec: "cyclonedx-min",
      components: [
        {
          name: "test-package",
          version: "1.0.0",
          type: "library"
        },
        {
          name: "suspicious-pkg",
          version: "2.0.0",
          type: "library",
          license: "GPL-3.0"
        }
      ],
      digest: "test-sbom-digest"
    };
    
    const mockRepro: ReproManifest = {
      v: 1,
      root: "/test",
      entries: [
        {
          path: "/test/file.js",
          digest: "test-file-digest",
          size: 1024,
          mode: 0o644
        },
        {
          path: "/test/suspicious.exe",
          digest: "test-exe-digest",
          size: 2048,
          mode: 0o755
        }
      ],
      digest: "test-repro-digest"
    };
    
    const mockProvenance: Provenance = {
      v: 1,
      commit: "a1b2c3d4e5f6789012345678901234567890abcd",
      blueprintDigest: "test-blueprint-digest",
      testsWitness: "test-tests-witness",
      perfSuiteWitness: "test-perf-witness",
      digest: "test-provenance-digest"
    };
    
    const mockSignedRelease: SignedRelease = {
      signature: "test-signature",
      bundle: {
        v: 1,
        reproDigest: "test-repro-digest",
        sbomDigest: "test-sbom-digest",
        provenanceDigest: "test-provenance-digest"
      },
      bundleDigest: "test-bundle-digest"
    };
    
    mockContext = {
      sbom: mockSBOM,
      repro: mockRepro,
      provenance: mockProvenance,
      signedRelease: mockSignedRelease,
      scanConfig: config
    };
  });

  it("should scan supply chain for vulnerabilities", async () => {
    const result = await scanner.scanSupplyChain(mockContext);
    
    expect(result).toBeDefined();
    expect(result.scanId).toBeDefined();
    expect(result.timestamp).toBeGreaterThan(0);
    expect(result.vulnerabilities).toBeInstanceOf(Array);
    expect(result.summary).toBeDefined();
    expect(result.riskScore).toBeGreaterThanOrEqual(0);
    expect(result.riskScore).toBeLessThanOrEqual(10);
    expect(result.recommendations).toBeInstanceOf(Array);
    expect(result.holographic_correspondence).toBeDefined();
    
    // Verify summary structure
    expect(result.summary.total).toBeGreaterThanOrEqual(0);
    expect(result.summary.critical).toBeGreaterThanOrEqual(0);
    expect(result.summary.high).toBeGreaterThanOrEqual(0);
    expect(result.summary.medium).toBeGreaterThanOrEqual(0);
    expect(result.summary.low).toBeGreaterThanOrEqual(0);
    expect(result.summary.info).toBeGreaterThanOrEqual(0);
  });

  it("should detect suspicious file extensions", async () => {
    const result = await scanner.scanSupplyChain(mockContext);
    
    // Should detect the suspicious .exe file
    const suspiciousFileVulns = result.vulnerabilities.filter(v => 
      v.id === 'file-suspicious-extension' && v.component === 'repro-manifest'
    );
    
    expect(suspiciousFileVulns.length).toBeGreaterThan(0);
    expect(suspiciousFileVulns[0].severity).toBe('medium');
    expect(suspiciousFileVulns[0].title).toContain('Suspicious file extension');
  });

  it("should detect problematic licenses", async () => {
    const result = await scanner.scanSupplyChain(mockContext);
    
    // Should detect the GPL-3.0 license
    const licenseVulns = result.vulnerabilities.filter(v => 
      v.id === 'license-gpl-3.0' && v.component === 'suspicious-pkg'
    );
    
    expect(licenseVulns.length).toBeGreaterThanOrEqual(0);
    expect(licenseVulns[0].severity).toBe('medium');
    expect(licenseVulns[0].title).toContain('Problematic license detected');
  });

  it("should detect suspicious package names", async () => {
    const result = await scanner.scanSupplyChain(mockContext);
    
    // Should detect the suspicious package name
    const suspiciousPkgVulns = result.vulnerabilities.filter(v => 
      v.id === 'dep-suspicious-name' && v.component === 'suspicious-pkg'
    );
    
    expect(suspiciousPkgVulns.length).toBeGreaterThan(0);
    expect(suspiciousPkgVulns[0].severity).toBe('medium');
    expect(suspiciousPkgVulns[0].title).toContain('Suspicious package name');
  });

  it("should maintain holographic correspondence", async () => {
    const result1 = await scanner.scanSupplyChain(mockContext);
    const result2 = await scanner.scanSupplyChain(mockContext);
    
    // Results should be deterministic (same scan ID)
    expect(result1.scanId).toBe(result2.scanId);
    expect(result1.holographic_correspondence).toBe(result2.holographic_correspondence);
    
    // All vulnerabilities should have holographic correspondence
    result1.vulnerabilities.forEach(vuln => {
      expect(vuln.holographic_correspondence).toBeDefined();
      expect(vuln.holographic_correspondence.length).toBeGreaterThan(0);
    });
  });

  it("should demonstrate cycle conservation", async () => {
    const startTime = Date.now();
    
    // Perform multiple scans
    const promises = [];
    for (let i = 0; i < 5; i++) {
      promises.push(scanner.scanSupplyChain(mockContext));
    }
    
    const results = await Promise.all(promises);
    const endTime = Date.now();
    
    // Should complete efficiently (cycle conservation)
    expect(endTime - startTime).toBeLessThan(1000); // Less than 1 second
    expect(results).toHaveLength(5);
    
    // All results should be valid
    results.forEach(result => {
      expect(result.scanId).toBeDefined();
      expect(result.vulnerabilities).toBeInstanceOf(Array);
    });
  });

  it("should demonstrate page conservation", async () => {
    const initialMemory = process.memoryUsage();
    
    // Perform many scans
    const promises = [];
    for (let i = 0; i < 20; i++) {
      promises.push(scanner.scanSupplyChain(mockContext));
    }
    
    await Promise.all(promises);
    const finalMemory = process.memoryUsage();
    
    // Memory usage should be reasonable (page conservation)
    const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;
    expect(memoryIncrease).toBeLessThan(20 * 1024 * 1024); // Less than 20MB increase
  });

  it("should filter vulnerabilities by severity threshold", async () => {
    const lowThresholdConfig = { ...config, severityThreshold: 'high' as const };
    const lowThresholdScanner = new VulnerabilityScanner(lowThresholdConfig);
    
    const result = await lowThresholdScanner.scanSupplyChain(mockContext);
    
    // Should only include high and critical vulnerabilities
    result.vulnerabilities.forEach(vuln => {
      expect(['critical', 'high']).toContain(vuln.severity);
    });
  });

  it("should cache scan results", async () => {
    const cacheConfig = { ...config, cacheResults: true };
    const cacheScanner = new VulnerabilityScanner(cacheConfig);
    
    // First scan
    const result1 = await cacheScanner.scanSupplyChain(mockContext);
    
    // Second scan should use cache
    const result2 = await cacheScanner.scanSupplyChain(mockContext);
    
    expect(result1.scanId).toBe(result2.scanId);
    expect(result1.timestamp).toBe(result2.timestamp);
    expect(result1.vulnerabilities).toEqual(result2.vulnerabilities);
  });

  it("should calculate risk score correctly", async () => {
    const result = await scanner.scanSupplyChain(mockContext);
    
    // Risk score should be based on vulnerability severity
    expect(result.riskScore).toBeGreaterThanOrEqual(0);
    expect(result.riskScore).toBeLessThanOrEqual(10);
    
    // If no vulnerabilities, risk should be 0
    if (result.vulnerabilities.length === 0) {
      expect(result.riskScore).toBe(0);
    }
  });

  it("should generate appropriate recommendations", async () => {
    const result = await scanner.scanSupplyChain(mockContext);
    
    expect(result.recommendations).toBeInstanceOf(Array);
    expect(result.recommendations.length).toBeGreaterThan(0);
    
    // Should have at least one recommendation
    result.recommendations.forEach(rec => {
      expect(typeof rec).toBe('string');
      expect(rec.length).toBeGreaterThan(0);
    });
  });

  it("should work with global instance", async () => {
    const globalScanner = getVulnerabilityScanner(config);
    
    const result = await globalScanner.scanSupplyChain(mockContext);
    
    expect(result).toBeDefined();
    expect(result.holographic_correspondence).toBeDefined();
    
    // Should be the same instance
    const globalScanner2 = getVulnerabilityScanner(config);
    expect(globalScanner).toBe(globalScanner2);
  });

  it("should handle invalid provenance gracefully", async () => {
    const invalidContext = {
      ...mockContext,
      provenance: {
        ...mockContext.provenance,
        commit: "invalid-commit-hash" // Invalid format
      }
    };
    
    const result = await scanner.scanSupplyChain(invalidContext);
    
    // Should detect the invalid commit
    const invalidCommitVulns = result.vulnerabilities.filter(v => 
      v.id === 'prov-commit-invalid'
    );
    
    expect(invalidCommitVulns.length).toBeGreaterThan(0);
    expect(invalidCommitVulns[0].severity).toBe('high');
  });

  it("should handle invalid digests gracefully", async () => {
    const invalidContext = {
      ...mockContext,
      provenance: {
        ...mockContext.provenance,
        blueprintDigest: "invalid-digest" // Invalid format
      }
    };
    
    const result = await scanner.scanSupplyChain(invalidContext);
    
    // Should detect the invalid digest
    const invalidDigestVulns = result.vulnerabilities.filter(v => 
      v.id === 'prov-blueprint-invalid'
    );
    
    expect(invalidDigestVulns.length).toBeGreaterThan(0);
    expect(invalidDigestVulns[0].severity).toBe('high');
  });

  it("should detect digest mismatches", async () => {
    const mismatchContext = {
      ...mockContext,
      signedRelease: {
        ...mockContext.signedRelease,
        bundle: {
          ...mockContext.signedRelease.bundle,
          sbomDigest: "different-sbom-digest" // Mismatch
        }
      }
    };
    
    const result = await scanner.scanSupplyChain(mismatchContext);
    
    // Should detect the digest mismatch
    const mismatchVulns = result.vulnerabilities.filter(v => 
      v.id === 'digest-sbom-mismatch'
    );
    
    expect(mismatchVulns.length).toBeGreaterThan(0);
    expect(mismatchVulns[0].severity).toBe('critical');
  });

  it("should provide detailed vulnerability information", async () => {
    const result = await scanner.scanSupplyChain(mockContext);
    
    result.vulnerabilities.forEach(vuln => {
      expect(vuln.id).toBeDefined();
      expect(vuln.severity).toMatch(/^(critical|high|medium|low|info)$/);
      expect(vuln.title).toBeDefined();
      expect(vuln.description).toBeDefined();
      expect(vuln.component).toBeDefined();
      expect(vuln.version).toBeDefined();
      expect(vuln.remediation).toBeDefined();
      expect(vuln.holographic_correspondence).toBeDefined();
    });
  });
});
